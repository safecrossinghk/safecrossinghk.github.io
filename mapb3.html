<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>è·¯ç·šå¤©æ°£èˆ‡äººæµè­¦å ±</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- Load Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Load Inter Font -->
<style>
body { font-family: 'Inter', sans-serif; }
/* è‡ªå®šç¾©æ¨£å¼ */
#map {
width: 100%;
height: 60vh;
border-radius: 12px;
overflow: hidden;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
.rain-alert {
animation: pulse-red 1s infinite alternate;
}
@keyframes pulse-red {
from { background-color: #fca5a5; } /* red-300 */
to { background-color: #ef4444; } /* red-500 */
}
.safe-alert {
background-color: #d1fae5; /* green-100 */
}
.busy-alert {
background-color: #fef3c7; /* yellow-100 */
color: #b45309; /* yellow-800 */
border: 2px solid #fbbf24; /* yellow-400 */
}
.loading-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(255, 255, 255, 0.7);
display: flex;
justify-content: center;
align-items: center;
font-size: 1.5rem;
border-radius: 12px;
z-index: 1000;
}
</style>
<!-- Load Leaflet CSS and JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
</head>
<body class="bg-gray-50 p-4 min-h-screen">

<div class="max-w-4xl mx-auto">
<h1 class="text-3xl font-extrabold text-center text-gray-800 mb-6 border-b pb-2">ğŸ§­ è·¯ç·šå¤©æ°£èˆ‡äººæµè­¦å ±ç³»çµ±</h1>

<div class="bg-white p-6 rounded-xl shadow-lg mb-6">
<div class="space-y-4 md:flex md:space-x-4 md:space-y-0">
<div class="flex-1">
<label for="startLocation" class="block text-sm font-medium text-gray-700 mb-1">èµ·é» (A)</label>
<input id="startLocation" type="text" placeholder="è¼¸å…¥èµ·é»ï¼Œä¾‹å¦‚ï¼šå°–æ²™å’€" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
</div>
<div class="flex-1">
<label for="endLocation" class="block text-sm font-medium text-gray-700 mb-1">çµ‚é» (B)</label>
<input id="endLocation" type="text" placeholder="è¼¸å…¥çµ‚é»ï¼Œä¾‹å¦‚ï¼šéŠ…é‘¼ç£" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
</div>
</div>
<button onclick="findRouteAndCheckRain()" id="routeButton" class="mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200 w-full">è¦åŠƒè·¯ç·šä¸¦æª¢æŸ¥è­¦å ±</button>
</div>

<div id="alertBox" class="p-4 rounded-xl text-center font-semibold mb-6 shadow-md hidden transition duration-500">
<!-- Alert message will be inserted here -->
</div>

<div id="mapContainer" class="relative">
<div id="map"></div>
<div id="loading" class="loading-overlay hidden">
<svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
</svg>
æ­£åœ¨è¦åŠƒè·¯ç·šä¸¦æª¢æŸ¥æ²¿ç·šè­¦å ±...
</div>
</div>

<div id="debugOutput" class="mt-6 p-4 bg-gray-100 rounded-lg text-sm text-gray-600 shadow-inner">
<!-- Debug/info output -->
<p><strong>è³‡è¨Šï¼š</strong>æœ¬æ‡‰ç”¨ç¨‹å¼çµåˆé™é›¨é å ±å’Œè·¯ç·šè¦åŠƒï¼Œä¸¦å…§ç½®äº†æ¨¡æ“¬çš„è‡ªè¨‚äººæµé»è­¦å ±ã€‚</p>
</div>
</div>

<script>
// ============== é…ç½®èˆ‡å…¨å±€è®Šé‡ ==============
let map;
let routeLayer; // ç”¨æ–¼å­˜æ”¾è·¯ç·šåœ–å±¤
const RAIN_API_URL = "https://crowdtest8r.ctakwah.workers.dev"; // æ‚¨çš„ Worker API
// [ä¿®æ”¹ 1] å°‡ "driving" æ”¹ç‚º "walking"
const OSRM_API_URL = "https://router.project-osrm.org/route/v1/walking/"; // OSRM Demo API (æ­¥è¡Œ)
const NOMINATIM_API_URL = "https://nominatim.openstreetmap.org/search?format=json&q=";

// [ä¿®æ”¹ 2] å°‡ 500 æ”¹ç‚º 1000
const SAMPLE_INTERVAL_METERS = 1000; // æ¯ 1000 ç±³ (1å…¬é‡Œ) å–æ¨£ä¸€å€‹é»é€²è¡Œå¤©æ°£æª¢æŸ¥
const POI_CHECK_DISTANCE_METERS = 500; // è·¯ç·šé™„è¿‘ 500 ç±³ç¯„åœå…§æª¢æŸ¥äººæµé»
const RAIN_THRESHOLD = 0.01; // é™é›¨é‡é–¾å€¼ (mm)
let poiMarkers = L.layerGroup(); // ç”¨æ–¼å­˜æ”¾äººæµé»æ¨™è¨˜

// æ¨¡æ“¬çš„è‡ªå®šç¾©äººæµé»æ•¸æ“š (POI)
// æ¨¡æ“¬ç‹€æ…‹: 1: æ­£å¸¸, 2: åå¤š, 3: ç¹å¿™
const CUSTOM_POIS = [
{ name: "æ—ºè§’ç«™", lat: 22.318357, lon: 114.169542, status: 3 }, // ç¹å¿™
{ name: "å°–æ²™å’€é˜æ¨“", lat: 22.293424, lon: 114.171170, status: 3 }, // ç¹å¿™
{ name: "ä¸­ç’°ç¢¼é ­", lat: 22.285810, lon: 114.156540, status: 2 }, // åå¤š
{ name: "é¦™æ¸¯ç§‘å­¸é¤¨", lat: 22.3000, lon: 114.1754, status: 1 }, // æ­£å¸¸
{ name: "é¦™æ¸¯æµ·æ´‹å…¬åœ’", lat: 22.2476, lon: 114.1755, status: 2 }, // åå¤š
{ name: "æ²™ç”°é¦¬å ´", lat: 22.4048, lon: 114.2155, status: 3 }, // ç¹å¿™ (å‡è¨­æœ‰è³½äº‹)
{ name: "é¦™æ¸¯åœ‹éš›æ©Ÿå ´", lat: 22.3089, lon: 113.9147, status: 3 }, // ç¹å¿™
];

// POI ç‹€æ…‹æ¨£å¼
const POI_STATUS_MAP = {
3: { label: 'ğŸ”´ éå¸¸ç¹å¿™', color: 'red', icon: 'ğŸš¨' },
2: { label: 'ğŸŸ¡ äººæµåå¤š', color: 'orange', icon: 'âš ï¸' },
1: { label: 'ğŸŸ¢ äººæµæ­£å¸¸', color: 'green', icon: 'ğŸš¶' }
};

// åˆå§‹åŒ–åœ°åœ–ï¼ˆé»˜èªé¦™æ¸¯ä¸­å¿ƒé»ï¼‰
window.onload = function() {
initMap(22.302711, 114.177216);
poiMarkers.addTo(map); // å°‡ POI åœ–å±¤åŠ å…¥åœ°åœ–
};

// ç›£è½ Enter éµ
document.getElementById("startLocation").addEventListener("keydown", function (e) {
if (e.key === "Enter") document.getElementById("endLocation").focus();
});
document.getElementById("endLocation").addEventListener("keydown", function (e) {
if (e.key === "Enter") findRouteAndCheckRain();
});

// ============== åœ°åœ–æ“ä½œå‡½æ•¸ ==============

function initMap(lat, lon) {
if (map) map.remove();
map = L.map("map").setView([lat, lon], 13);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
maxZoom: 19,
attribution: 'Â© OpenStreetMap contributors'
}).addTo(map);
poiMarkers = L.layerGroup().addTo(map); // é‡è¨­ POI åœ–å±¤
}

function showLoading(show) {
document.getElementById('loading').classList.toggle('hidden', !show);
document.getElementById('routeButton').disabled = show;
}

function setAlert(message, type = 'safe') {
const alertBox = document.getElementById('alertBox');
alertBox.classList.remove('hidden', 'rain-alert', 'safe-alert', 'busy-alert', 'bg-red-100', 'bg-green-100', 'bg-yellow-100', 'text-red-800', 'text-green-800', 'text-yellow-800', 'border-red-400', 'border-green-400', 'border-yellow-400');
alertBox.style.borderColor = 'initial'; // æ¸…é™¤ inline style

if (type === 'rain') {
alertBox.classList.add('rain-alert', 'bg-red-100', 'text-red-800', 'border-red-400');
} else if (type === 'busy') {
// ä½¿ç”¨ custom busy-alert style
alertBox.classList.add('busy-alert');
} else if (type === 'safe') {
alertBox.classList.add('safe-alert', 'bg-green-100', 'text-green-800', 'border-green-400');
} else {
alertBox.classList.add('bg-gray-100', 'text-gray-800');
}
alertBox.innerHTML = message;
}


// ============== æ ¸å¿ƒï¼šè·¯å¾‘è¦åŠƒèˆ‡è­¦å ±æª¢æŸ¥ ==============

/*** åŸ·è¡Œæ•´å€‹æµç¨‹ï¼šæŸ¥è©¢åº§æ¨™ -> è¦åŠƒè·¯ç·š -> æª¢æŸ¥æ²¿ç·šå¤©æ°£ -> æª¢æŸ¥æ²¿ç·šäººæµ POI*/
async function findRouteAndCheckRain() {
showLoading(true);
setAlert("è¦åŠƒè·¯ç·šä¸­...", 'info');
poiMarkers.clearLayers(); // æ¸…é™¤èˆŠçš„ POI æ¨™è¨˜

const startLoc = document.getElementById('startLocation').value.trim();
const endLoc = document.getElementById('endLocation').value.trim();

if (!startLoc || !endLoc) {
setAlert("â— è«‹è¼¸å…¥èµ·é»å’Œçµ‚é»ã€‚", 'info');
showLoading(false);
return;
}

try {
// 1. ç²å– A, B é»åº§æ¨™
const startCoords = await getCoordinates(startLoc);
const endCoords = await getCoordinates(endLoc);

if (!startCoords || !endCoords) {
setAlert("âŒ ç„¡æ³•æ‰¾åˆ°èµ·é»æˆ–çµ‚é»çš„ç²¾ç¢ºåº§æ¨™ã€‚", 'error');
showLoading(false);
return;
}

// é‡è¨­åœ°åœ–ä¸­å¿ƒå’Œæ¨™è¨˜
initMap(startCoords.lat, startCoords.lon);
L.marker([startCoords.lat, startCoords.lon]).addTo(map).bindPopup("èµ·é»").openPopup();
L.marker([endCoords.lat, endCoords.lon]).addTo(map).bindPopup("çµ‚é»");

// 2. è¦åŠƒè·¯ç·š
const routeData = await getOSRMRoute(startCoords, endCoords);

// 3. ç¹ªè£½è·¯ç·šä¸¦ç²å–å–æ¨£é»
const sampledPoints = drawRouteAndSamplePoints(routeData);

// 4. æª¢æŸ¥æ²¿ç·šé™é›¨
const rainStatus = await checkRainForSampledPoints(sampledPoints);

// 5. æª¢æŸ¥æ²¿ç·šè‡ªå®šç¾©äººæµé»
const busyPOIs = checkCustomPOIsNearRoute(sampledPoints);

// 6. ç¶œåˆè­¦å ±é¡¯ç¤º
updateCombinedAlert(rainStatus, busyPOIs);

} catch (error) {
console.error("âŒ è·¯ç·šè¦åŠƒæˆ–è­¦å ±æª¢æŸ¥ç™¼ç”ŸéŒ¯èª¤:", error);
setAlert(`âŒ è™•ç†å¤±æ•—ï¼š${error.message} (è©³æƒ…è«‹æŸ¥çœ‹æ§åˆ¶å°)`, 'error');
} finally {
showLoading(false);
}
}

/*** æ ¹æ“šé—œéµå­—ç²å–ç¶“ç·¯åº¦ (ä½¿ç”¨ Nominatim)*/
async function getCoordinates(query) {
const url = NOMINATIM_API_URL + encodeURIComponent(query);
const response = await fetch(url);
const data = await response.json();

if (data && data.length > 0) {
return {
lat: parseFloat(data[0].lat),
lon: parseFloat(data[0].lon)
};
}
return null;
}

/*** å‘¼å« OSRM è¦åŠƒè·¯ç·š*/
async function getOSRMRoute(start, end) {
const coords = `${start.lon},${start.lat};${end.lon},${end.lat}`;
// æ³¨æ„ï¼šOSRM_API_URL å·²åœ¨é ‚éƒ¨ä¿®æ”¹ç‚º "walking"
const url = `${OSRM_API_URL}${coords}?overview=full&steps=true&geometries=geojson`;

const response = await fetch(url);
if (!response.ok) {
throw new Error(`OSRM æœå‹™éŒ¯èª¤: ${response.statusText}`);
}
const data = await response.json();

if (data.code !== 'Ok' || data.routes.length === 0) {
throw new Error("æ‰¾ä¸åˆ°æœ‰æ•ˆçš„æ­¥è¡Œè·¯ç·šã€‚"); // åŒæ™‚æ›´æ–°éŒ¯èª¤è¨Šæ¯
}
return data.routes[0];
}

/*** ç¹ªè£½è·¯ç·šï¼Œä¸¦æ²¿è‘—ç·šè·¯å–æ¨£åº§æ¨™é»* @returns {Array<object>} æ²¿ç·šå–æ¨£é»çš„ç¶“ç·¯åº¦é™£åˆ—*/
function drawRouteAndSamplePoints(route) {
if (routeLayer) map.removeLayer(routeLayer);

const geojson = route.geometry;
const coordinates = geojson.coordinates; // [lon, lat] æ ¼å¼çš„é™£åˆ—

// å°‡ OSRM çš„ [lon, lat] è½‰ç‚º Leaflet çš„ [lat, lon]
const latLngs = coordinates.map(coord => [coord[1], coord[0]]);

routeLayer = L.polyline(latLngs, {
color: '#1d4ed8', // blue-700
weight: 6,
opacity: 0.8,
dashArray: '5, 10' // æ·»åŠ è™›ç·šæ¨£å¼ä»¥å€åˆ†æ­¥è¡Œ
}).addTo(map);

// èª¿æ•´åœ°åœ–è¦–é‡ä»¥é©æ‡‰è·¯ç·š
map.fitBounds(routeLayer.getBounds());

// æ²¿ç·šå–æ¨£é» (ç°¡å–®çš„è·é›¢æ¡æ¨£)
const sampledPoints = [];
let lastSampledCoord = latLngs[0];
sampledPoints.push({ lat: lastSampledCoord[0], lon: lastSampledCoord[1] });

let accumulatedDistance = 0;

for (let i = 1; i < latLngs.length; i++) {
const currentCoord = latLngs[i];
const segmentDistance = map.distance(lastSampledCoord, currentCoord);
accumulatedDistance += segmentDistance;

// æ³¨æ„ï¼šSAMPLE_INTERVAL_METERS å·²åœ¨é ‚éƒ¨ä¿®æ”¹ç‚º 1000
if (accumulatedDistance >= SAMPLE_INTERVAL_METERS) {
sampledPoints.push({ lat: currentCoord[0], lon: currentCoord[1] });
lastSampledCoord = currentCoord;
accumulatedDistance = 0; // é‡ç½®ç´¯ç©è·é›¢
}
}

document.getElementById('debugOutput').innerHTML = `<strong>è·¯ç·šè³‡è¨Šï¼š</strong><br>
ç¸½è·é›¢ï¼šç´„ ${(route.distance / 1000).toFixed(2)} å…¬é‡Œ<br>
é è¨ˆæ™‚é–“ï¼šç´„ ${(route.duration / 60).toFixed(0)} åˆ†é˜<br>
æª¢æŸ¥é»æ•¸é‡ï¼š${sampledPoints.length} å€‹ (æ¯ ${SAMPLE_INTERVAL_METERS} ç±³å–æ¨£)`;

return sampledPoints;
}

// ============== å¤©æ°£æª¢æŸ¥å‡½æ•¸ ==============

/*** æª¢æŸ¥æ‰€æœ‰å–æ¨£é»çš„é™é›¨æƒ…æ³* @param {Array<object>} points ç¶“ç·¯åº¦é»é™£åˆ—* @returns {object} é™é›¨æª¢æŸ¥çµæœ*/
async function checkRainForSampledPoints(points) {

let rainPointsCount = 0;
const checkPromises = points.map(point => checkSinglePointRain(point.lat, point.lon));
const results = await Promise.all(checkPromises);

const rainResults = results.filter(r => r.rainExpected);
rainPointsCount = rainResults.length;

// ç§»é™¤èˆŠçš„é›¨é»æ¨™è¨˜
map.eachLayer(layer => {
if (layer instanceof L.CircleMarker && layer.options.color === 'red') {
map.removeLayer(layer);
}
});

if (rainPointsCount > 0) {
// æ‰¾å‡ºæœ€æ¥è¿‘æœ€å¤§é›¨é‡çš„çµæœï¼Œç”¨æ–¼å±•ç¤º
const maxRainPoint = rainResults.sort((a, b) => b.immediateRain - a.immediateRain)[0];

// åœ¨åœ°åœ–ä¸Šæ¨™è¨˜é™é›¨é»
rainResults.forEach(r => {
const lat = r.location.lat;
const lon = r.location.lon;
// ä½¿ç”¨åœ“å½¢æ¨™è¨˜è¡¨ç¤ºé™é›¨é»
L.circleMarker([lat, lon], {
radius: 8,
color: 'red',
fillColor: '#f03',
fillOpacity: 0.7,
}).addTo(map).bindPopup(`<strong>ğŸŒ§ï¸ é™é›¨æç¤º</strong><br>é è¨ˆé›¨é‡: ${r.immediateRain} mm/hr`);
});

return {
hasRain: true,
count: rainPointsCount,
maxRain: maxRainPoint.immediateRain
};

} else {
return { hasRain: false };
}
}

/*** å‘¼å« Worker API æª¢æŸ¥å–®ä¸€åº§æ¨™é»çš„é™é›¨æƒ…æ³*/
async function checkSinglePointRain(lat, lon) {
// æ³¨æ„ï¼šé€™è£¡ä½¿ç”¨æ‚¨æä¾›çš„ Worker API
const url = `${RAIN_API_URL}/?lat=${lat}&lon=${lon}`;
const response = await fetch(url);

if (!response.ok) {
throw new Error("å¤©æ°£ Worker è«‹æ±‚å¤±æ•—ã€‚");
}

const data = await response.json();

data.location = { lat, lon };
return data;
}

// ============== äººæµ POI æª¢æŸ¥å‡½æ•¸ ==============

/*** æª¢æŸ¥è‡ªå®šç¾©äººæµé»æ˜¯å¦ä½æ–¼è·¯ç·šé™„è¿‘* @param {Array<object>} routePoints è·¯ç·šå–æ¨£é»* @returns {Array<object>} è·¯ç·šé™„è¿‘çš„ç¹å¿™ POI*/
function checkCustomPOIsNearRoute(routePoints) {
const nearbyPOIs = new Set();
const busyPOIs = [];

// ç§»é™¤èˆŠçš„ POI æ¨™è¨˜ (éé™é›¨æ¨™è¨˜)
poiMarkers.clearLayers();

// éæ­·æ‰€æœ‰ POI
for (const poi of CUSTOM_POIS) {
let isNearby = false;

// æª¢æŸ¥ POI èˆ‡è·¯ç·šä¸Šä»»ä¸€é»çš„è·é›¢
for (const routePoint of routePoints) {
// ä½¿ç”¨ Leaflet å…§å»ºæ–¹æ³•è¨ˆç®—è·é›¢ (ç±³)
const distance = map.distance([poi.lat, poi.lon], [routePoint.lat, routePoint.lon]);

if (distance <= POI_CHECK_DISTANCE_METERS) {
isNearby = true;
break;
}
}

if (isNearby) {
if (poi.status >= 2) { // ç‹€æ…‹ç‚º åå¤š æˆ– ç¹å¿™
busyPOIs.push(poi);
}

// ç„¡è«–æ˜¯å¦ç¹å¿™ï¼Œéƒ½åœ¨åœ°åœ–ä¸Šæ¨™è¨˜
const statusInfo = POI_STATUS_MAP[poi.status];

const customIcon = L.divIcon({
className: 'custom-poi-marker',
html: `<div class="bg-${statusInfo.color}-600 text-white text-lg rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 border-white font-bold" style="background-color: ${statusInfo.color === 'red' ? '#dc2626' : statusInfo.color === 'orange' ? '#f97316' : '#10b981'};">${statusInfo.icon}</div>`,
iconSize: [32, 32],
iconAnchor: [16, 32],
popupAnchor: [0, -32]
});

L.marker([poi.lat, poi.lon], { icon: customIcon })
.addTo(poiMarkers)
.bindPopup(`<strong>${poi.name}</strong><br>äººæµç‹€æ…‹: ${statusInfo.label}`);
}
}

return busyPOIs;
}


// ============== ç¶œåˆè­¦å ±å‡½æ•¸ ==============

/*** æ ¹æ“šå¤©æ°£å’Œäººæµçµæœæ›´æ–°è­¦å ±æ¡†*/
function updateCombinedAlert(rainStatus, busyPOIs) {
let combinedMessage = ``;
let alertType = 'safe';
let rainText = "";
let poiText = "";
let speechText = "";

// 1. è™•ç†å¤©æ°£è­¦å ±
if (rainStatus.hasRain) {
rainText = `ğŸ”´ **å¤©æ°£è­¦å ±**ï¼šè·¯ç·šä¸Šæœ‰ ${rainStatus.count} è™•é è¨ˆæœ‰é›¨ï¼<br>(æœ€é«˜é›¨é‡: ${rainStatus.maxRain} mm/hr)`;
alertType = 'rain'; // å¤©æ°£è­¦å ±å„ªå…ˆ
speechText += "æ³¨æ„ï¼Œè·¯ç·šä¸Šæœ‰é™é›¨é å ±ã€‚";
} else {
rainText = `ğŸŸ¢ **å¤©æ°£å®‰å…¨**ï¼šé è¨ˆæ²¿é€”æ²’æœ‰é™é›¨ã€‚`;
}

// 2. è™•ç†äººæµè­¦å ±
if (busyPOIs.length > 0) {
const names = busyPOIs.map(p => p.name).join('ã€');
poiText = `âš ï¸ **äººæµè­¦å ±**ï¼šè·¯ç·šé™„è¿‘æœ‰ ${busyPOIs.length} å€‹ç¹å¿™/åå¤šåœ°é»ï¼š${names}ã€‚`;

// å¦‚æœæ²’æœ‰ä¸‹é›¨ï¼Œå‰‡äººæµè­¦å ±ä½œç‚ºä¸»è¦è­¦å ±é¡å‹
if (alertType !== 'rain') {
alertType = 'busy';
}
speechText += `è«‹ç•™æ„è·¯ç·šé™„è¿‘ ${names} çš„äººæµæƒ…æ³ã€‚`;

} else {
poiText = `âœ… **äººæµå®‰å…¨**ï¼šè·¯ç·šé™„è¿‘æ²’æœ‰ç‰¹åˆ¥ç¹å¿™çš„åœ°é»ã€‚`;
}

// 3. çµ„åˆæ¶ˆæ¯
combinedMessage = `${rainText}<br><br>${poiText}`;

// 4. æ›´æ–° UI
setAlert(combinedMessage, alertType);

// 5. èªéŸ³æç¤º
if (speechText.length > 0) {
const finalSpeech = new SpeechSynthesisUtterance(speechText);
finalSpeech.lang = "zh-HK";
speechSynthesis.speak(finalSpeech);
} else {
// å¦‚æœå…©è€…çš†ç„¡è­¦å ±
const safeSpeech = new SpeechSynthesisUtterance("è·¯ç·šå®‰å…¨ï¼Œæ²’æœ‰å¤©æ°£æˆ–äººæµè­¦å ±ã€‚");
safeSpeech.lang = "zh-HK";
speechSynthesis.speak(safeSpeech);
}
}
</script>
</body>
</html>