<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>è·¯ç·šå¤©æ°£é è­¦</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- Load Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Load Inter Font -->
<style>
body { font-family: 'Inter', sans-serif; }
/* è‡ªå®šç¾©æ¨£å¼ */
#map {
width: 100%;
height: 60vh;
border-radius: 12px;
overflow: hidden;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
.rain-alert {
animation: pulse-red 1s infinite alternate;
}
@keyframes pulse-red {
from { background-color: #fca5a5; } /* red-300 */
to { background-color: #ef4444; } /* red-500 */
}
.rain-safe {
background-color: #d1fae5; /* green-100 */
}
.loading-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(255, 255, 255, 0.7);
display: flex;
justify-content: center;
align-items: center;
font-size: 1.5rem;
border-radius: 12px;
z-index: 1000;
}
</style>
<!-- Load Leaflet CSS and JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
</head>
<body class="bg-gray-50 p-4 min-h-screen">

<div class="max-w-4xl mx-auto">
<h1 class="text-3xl font-extrabold text-center text-gray-800 mb-6 border-b pb-2">ğŸ§­ è·¯ç·šé™é›¨é è­¦ç³»çµ± (ç´”å¤©æ°£)</h1>

<div class="bg-white p-6 rounded-xl shadow-lg mb-6">
<div class="space-y-4 md:flex md:space-x-4 md:space-y-0">
<div class="flex-1">
<label for="startLocation" class="block text-sm font-medium text-gray-700 mb-1">èµ·é» (A)</label>
<input id="startLocation" type="text" placeholder="è¼¸å…¥èµ·é»ï¼Œä¾‹å¦‚ï¼šå°–æ²™å’€" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
</div>
<div class="flex-1">
<label for="endLocation" class="block text-sm font-medium text-gray-700 mb-1">çµ‚é» (B)</label>
<input id="endLocation" type="text" placeholder="è¼¸å…¥çµ‚é»ï¼Œä¾‹å¦‚ï¼šéŠ…é‘¼ç£" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
</div>
</div>
<button onclick="findRouteAndCheckRain()" id="routeButton" class="mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200 w-full">
è¦åŠƒè·¯ç·šä¸¦æª¢æŸ¥å¤©æ°£
</button>
</div>

<div id="alertBox" class="p-4 rounded-xl text-center font-semibold mb-6 shadow-md hidden transition duration-500">
<!-- Alert message will be inserted here -->
</div>

<div id="mapContainer" class="relative">
<div id="map"></div>
<div id="loading" class="loading-overlay hidden">
<svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
</svg>
æ­£åœ¨è¦åŠƒè·¯ç·šä¸¦æª¢æŸ¥æ²¿ç·šå¤©æ°£...
</div>
</div>

<div id="debugOutput" class="mt-6 p-4 bg-gray-100 rounded-lg text-sm text-gray-600 shadow-inner">
<!-- Debug/info output -->
<p><strong>è³‡è¨Šï¼š</strong>æœ¬æ‡‰ç”¨ç¨‹å¼åˆ©ç”¨é¦™æ¸¯å¤©æ–‡å°é™é›¨æ•¸æ“šå’Œé–‹æºè·¯ç”±æœå‹™ OSRM é€²è¡Œè·¯ç·šåˆ†æã€‚</p>
</div>
</div>

<script>
// ============== é…ç½®èˆ‡å…¨å±€è®Šé‡ ==============
let map;
let routeLayer; // ç”¨æ–¼å­˜æ”¾è·¯ç·šåœ–å±¤
// æ‚¨çš„ Worker API ç¶²å€ï¼Œç”¨æ–¼æŸ¥è©¢é™é›¨é å ±
const RAIN_API_URL = "https://crowdtest8r.ctakwah.workers.dev";
// OSRM æ¼”ç¤º APIï¼Œç”¨æ–¼è·¯ç·šè¦åŠƒ
const OSRM_API_URL = "https://router.project-osrm.org/route/v1/driving/";
// Nominatim APIï¼Œç”¨æ–¼åœ°é»åç¨±è½‰ç¶“ç·¯åº¦
const NOMINATIM_API_URL = "https://nominatim.openstreetmap.org/search?format=json&q=";
const SAMPLE_INTERVAL_METERS = 500; // æ¯ 500 ç±³å–æ¨£ä¸€å€‹é»é€²è¡Œå¤©æ°£æª¢æŸ¥
const RAIN_THRESHOLD = 0.01; // é™é›¨é‡é–¾å€¼ (mm)

// åˆå§‹åŒ–åœ°åœ–ï¼ˆé»˜èªé¦™æ¸¯ä¸­å¿ƒé»ï¼‰
window.onload = function() {
initMap(22.302711, 114.177216);
};

// ç›£è½ Enter éµ
document.getElementById("startLocation").addEventListener("keydown", function (e) {
if (e.key === "Enter") document.getElementById("endLocation").focus();
});
document.getElementById("endLocation").addEventListener("keydown", function (e) {
if (e.key === "Enter") findRouteAndCheckRain();
});

// ============== åœ°åœ–æ“ä½œå‡½æ•¸ ==============

function initMap(lat, lon) {
if (map) map.remove();
map = L.map("map").setView([lat, lon], 13);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
maxZoom: 19,
attribution: 'Â© OpenStreetMap contributors'
}).addTo(map);
}

function showLoading(show) {
document.getElementById('loading').classList.toggle('hidden', !show);
document.getElementById('routeButton').disabled = show;
}

function setAlert(message, type = 'safe') {
const alertBox = document.getElementById('alertBox');
alertBox.classList.remove('hidden', 'rain-alert', 'rain-safe', 'bg-red-100', 'bg-green-100', 'text-red-800', 'text-green-800', 'bg-yellow-100', 'text-yellow-800');

if (type === 'rain') {
alertBox.classList.add('rain-alert', 'bg-red-100', 'text-red-800');
} else if (type === 'safe') {
alertBox.classList.add('rain-safe', 'bg-green-100', 'text-green-800');
} else {
alertBox.classList.add('bg-yellow-100', 'text-yellow-800');
}
alertBox.innerHTML = message;
}


// ============== æ ¸å¿ƒï¼šè·¯å¾‘è¦åŠƒèˆ‡å¤©æ°£æª¢æŸ¥ ==============

/**
* åŸ·è¡Œæ•´å€‹æµç¨‹ï¼šæŸ¥è©¢åº§æ¨™ -> è¦åŠƒè·¯ç·š -> æª¢æŸ¥æ²¿ç·šå¤©æ°£
*/
async function findRouteAndCheckRain() {
showLoading(true);
setAlert("è¦åŠƒè·¯ç·šä¸­...", 'info');

const startLoc = document.getElementById('startLocation').value.trim();
const endLoc = document.getElementById('endLocation').value.trim();

if (!startLoc || !endLoc) {
setAlert("â— è«‹è¼¸å…¥èµ·é»å’Œçµ‚é»ã€‚", 'info');
showLoading(false);
return;
}

try {
// 1. ç²å– A, B é»åº§æ¨™
const startCoords = await getCoordinates(startLoc);
const endCoords = await getCoordinates(endLoc);

if (!startCoords || !endCoords) {
setAlert("âŒ ç„¡æ³•æ‰¾åˆ°èµ·é»æˆ–çµ‚é»çš„ç²¾ç¢ºåº§æ¨™ã€‚", 'error');
showLoading(false);
return;
}

// é‡è¨­åœ°åœ–ä¸­å¿ƒå’Œæ¨™è¨˜
initMap(startCoords.lat, startCoords.lon);
L.marker([startCoords.lat, startCoords.lon]).addTo(map).bindPopup("èµ·é»").openPopup();
L.marker([endCoords.lat, endCoords.lon]).addTo(map).bindPopup("çµ‚é»");

// 2. è¦åŠƒè·¯ç·š
const routeData = await getOSRMRoute(startCoords, endCoords);

// 3. ç¹ªè£½è·¯ç·šä¸¦ç²å–å–æ¨£é»
const sampledPoints = drawRouteAndSamplePoints(routeData);

// 4. æª¢æŸ¥æ²¿ç·šé™é›¨
if (sampledPoints.length > 0) {
await checkRainForSampledPoints(sampledPoints);
} else {
setAlert("âš ï¸ è·¯ç·šéçŸ­æˆ–ç„¡æœ‰æ•ˆè·¯å¾‘é»å¯ä¾›æª¢æŸ¥ã€‚", 'info');
}

} catch (error) {
console.error("âŒ è·¯ç·šè¦åŠƒæˆ–å¤©æ°£æª¢æŸ¥ç™¼ç”ŸéŒ¯èª¤:", error);
setAlert(`âŒ è™•ç†å¤±æ•—ï¼š${error.message} (è©³æƒ…è«‹æŸ¥çœ‹æ§åˆ¶å°)`, 'error');
} finally {
showLoading(false);
}
}

/**
* æ ¹æ“šé—œéµå­—ç²å–ç¶“ç·¯åº¦ (ä½¿ç”¨ Nominatim)
*/
async function getCoordinates(query) {
const url = NOMINATIM_API_URL + encodeURIComponent(query);
const response = await fetch(url);
const data = await response.json();

if (data && data.length > 0) {
return {
lat: parseFloat(data[0].lat),
lon: parseFloat(data[0].lon)
};
}
return null;
}

/**
* å‘¼å« OSRM è¦åŠƒè·¯ç·š
*/
async function getOSRMRoute(start, end) {
const coords = `${start.lon},${start.lat};${end.lon},${end.lat}`;
const url = `${OSRM_API_URL}${coords}?overview=full&steps=true&geometries=geojson`;

const response = await fetch(url);
if (!response.ok) {
throw new Error(`OSRM æœå‹™éŒ¯èª¤: ${response.statusText}`);
}
const data = await response.json();

if (data.code !== 'Ok' || data.routes.length === 0) {
throw new Error("æ‰¾ä¸åˆ°æœ‰æ•ˆçš„é§•é§›è·¯ç·šã€‚");
}
return data.routes[0];
}

/**
* ç¹ªè£½è·¯ç·šï¼Œä¸¦æ²¿è‘—ç·šè·¯å–æ¨£åº§æ¨™é»
* @returns {Array<object>} æ²¿ç·šå–æ¨£é»çš„ç¶“ç·¯åº¦é™£åˆ—
*/
function drawRouteAndSamplePoints(route) {
if (routeLayer) map.removeLayer(routeLayer);

const geojson = route.geometry;
const coordinates = geojson.coordinates; // [lon, lat] æ ¼å¼çš„é™£åˆ—

// å°‡ OSRM çš„ [lon, lat] è½‰ç‚º Leaflet çš„ [lat, lon]
const latLngs = coordinates.map(coord => [coord[1], coord[0]]);

routeLayer = L.polyline(latLngs, {
color: '#1d4ed8', // blue-700
weight: 6,
opacity: 0.8
}).addTo(map);

// èª¿æ•´åœ°åœ–è¦–é‡ä»¥é©æ‡‰è·¯ç·š
map.fitBounds(routeLayer.getBounds());

// æ²¿ç·šå–æ¨£é» (ç°¡å–®çš„è·é›¢æ¡æ¨£)
const sampledPoints = [];
let lastSampledCoord = latLngs[0];
sampledPoints.push({ lat: lastSampledCoord[0], lon: lastSampledCoord[1] });

let accumulatedDistance = 0;

for (let i = 1; i < latLngs.length; i++) {
const currentCoord = latLngs[i];
const segmentDistance = map.distance(lastSampledCoord, currentCoord);
accumulatedDistance += segmentDistance;

if (accumulatedDistance >= SAMPLE_INTERVAL_METERS) {
sampledPoints.push({ lat: currentCoord[0], lon: currentCoord[1] });
lastSampledCoord = currentCoord;
accumulatedDistance = 0; // é‡ç½®ç´¯ç©è·é›¢
}
}

document.getElementById('debugOutput').innerHTML = `
<strong>è·¯ç·šè³‡è¨Šï¼š</strong><br>
ç¸½è·é›¢ï¼šç´„ ${(route.distance / 1000).toFixed(2)} å…¬é‡Œ<br>
é è¨ˆæ™‚é–“ï¼šç´„ ${(route.duration / 60).toFixed(0)} åˆ†é˜<br>
æª¢æŸ¥é»æ•¸é‡ï¼š${sampledPoints.length} å€‹ (æ¯ ${SAMPLE_INTERVAL_METERS} ç±³å–æ¨£)
`;

return sampledPoints;
}

// ============== å¤©æ°£æª¢æŸ¥å‡½æ•¸ ==============

/**
* æª¢æŸ¥æ‰€æœ‰å–æ¨£é»çš„é™é›¨æƒ…æ³
* @param {Array<object>} points ç¶“ç·¯åº¦é»é™£åˆ—
*/
async function checkRainForSampledPoints(points) {
setAlert(`æ­£åœ¨æª¢æŸ¥ ${points.length} å€‹æ²¿ç·šä½ç½®çš„é™é›¨æƒ…æ³...`, 'info');

let rainPointsCount = 0;
const checkPromises = points.map(point => checkSinglePointRain(point.lat, point.lon));
const results = await Promise.all(checkPromises);

// éæ¿¾å‡ºé è¨ˆæœ‰é›¨çš„é»
const rainResults = results.filter(r => r.rainExpected);
rainPointsCount = rainResults.length;

// ç§»é™¤èˆŠçš„é›¨é»æ¨™è¨˜ (L.CircleMarker)
map.eachLayer(layer => {
if (layer instanceof L.CircleMarker) {
map.removeLayer(layer);
}
});

if (rainPointsCount > 0) {
// æ‰¾å‡ºæœ€æ¥è¿‘æœ€å¤§é›¨é‡çš„çµæœï¼Œç”¨æ–¼å±•ç¤º
const maxRainPoint = rainResults.sort((a, b) => b.immediateRain - a.immediateRain)[0];

setAlert(`
ğŸ”´ **æ³¨æ„ï¼** æ‚¨çš„è·¯ç·šä¸Šæœ‰ ${rainPointsCount} å€‹åœ°é»é è¨ˆå°‡æœƒä¸‹é›¨ï¼<br>
æœ€é«˜é™é›¨é‡ï¼š${maxRainPoint.immediateRain} mm/hr (åœ¨ç¶“ç·¯åº¦ ${maxRainPoint.location.lat.toFixed(4)}, ${maxRainPoint.location.lon.toFixed(4)})
`, 'rain');

// åœ¨åœ°åœ–ä¸Šæ¨™è¨˜é™é›¨é»
rainResults.forEach(r => {
const lat = r.location.lat;
const lon = r.location.lon;
// ä½¿ç”¨åœ“å½¢æ¨™è¨˜è¡¨ç¤ºé™é›¨é»
L.circleMarker([lat, lon], {
radius: 8,
color: 'red',
fillColor: '#f03',
fillOpacity: 0.7,
}).addTo(map).bindPopup(`<strong>ğŸŒ§ï¸ é™é›¨æç¤º</strong><br>é è¨ˆé›¨é‡: ${r.immediateRain} mm/hr`);
});

} else {
setAlert("ğŸŸ¢ **è·¯ç·šå®‰å…¨**ï¼šé è¨ˆæ²¿é€”è·¯ç·šæ²’æœ‰é™é›¨ã€‚", 'safe');
}

// èªéŸ³æç¤º
const msg = new SpeechSynthesisUtterance(
rainPointsCount > 0
? `æ³¨æ„ï¼Œè·¯ç·šä¸Šæœ‰ ${rainPointsCount} å€‹åœ°é»é è¨ˆå°‡æœƒä¸‹é›¨ã€‚`
: `è·¯ç·šå®‰å…¨ï¼Œé è¨ˆæ²¿é€”æ²’æœ‰é™é›¨ã€‚`
);
msg.lang = "zh-HK";
speechSynthesis.speak(msg);
}

/**
* å‘¼å« Worker API æª¢æŸ¥å–®ä¸€åº§æ¨™é»çš„é™é›¨æƒ…æ³
*/
async function checkSinglePointRain(lat, lon) {
// é€™è£¡å‡è¨­æ‚¨çš„ Worker API æ”¯æ´ lat å’Œ lon æŸ¥è©¢
const url = `${RAIN_API_URL}/?lat=${lat}&lon=${lon}`;
const response = await fetch(url);

if (!response.ok) {
// å˜—è©¦å°‡éŸ¿æ‡‰ä¸»é«”ä½œç‚ºéŒ¯èª¤è¨Šæ¯è§£æ
const errorText = await response.text();
console.error("Worker API éŒ¯èª¤è©³æƒ…:", errorText);
throw new Error(`å¤©æ°£ Worker è«‹æ±‚å¤±æ•—ï¼Œç‹€æ…‹ç¢¼: ${response.status}`);
}

const data = await response.json();

// ç¢ºä¿è¿”å›çš„ç‰©ä»¶çµæ§‹ç¬¦åˆé æœŸï¼Œè‡³å°‘åŒ…å«ä½ç½®ä¿¡æ¯ï¼Œå³ä½¿æ²’æœ‰é™é›¨é å ±æ¬„ä½
data.location = { lat, lon };

// ç¢ºä¿æœ‰ rainExpected æ¬„ä½ï¼Œå¦‚æœ Worker æ²’æœ‰æ˜ç¢ºè¿”å›ï¼Œå‰‡é è¨­ç‚º false
if (typeof data.rainExpected === 'undefined') {
// ç‚ºäº†å…¼å®¹æ€§ï¼Œæˆ‘å€‘å¯ä»¥æ ¹æ“š immediateRain åˆ¤æ–·
data.rainExpected = data.immediateRain > RAIN_THRESHOLD;
}

return data;
}

</script>
</body>
</html>
