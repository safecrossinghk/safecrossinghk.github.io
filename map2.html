<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>è·¯ç·šå¤©æ°£èˆ‡äººæµè­¦å ±</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- Load Tailwind CSS -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Load Inter Font -->
<style>
body { font-family: 'Inter', sans-serif; }
/* è‡ªå®šç¾©æ¨£å¼ */
#map {
width: 100%;
height: 60vh;
border-radius: 12px;
overflow: hidden;
box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}
.rain-alert {
animation: pulse-red 1s infinite alternate;
}
@keyframes pulse-red {
from { background-color: #fca5a5; } /* red-300 */
to { background-color: #ef4444; } /* red-500 */
}
.safe-alert {
background-color: #d1fae5; /* green-100 */
}
.busy-alert {
background-color: #fef3c7; /* yellow-100 */
color: #b45309; /* yellow-800 */
border: 2px solid #fbbf24; /* yellow-400 */
}
.loading-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(255, 255, 255, 0.7);
display: flex;
justify-content: center;
align-items: center;
font-size: 1.5rem;
border-radius: 12px;
z-index: 1000;
}
/* POI Marker Style */
.custom-poi-marker {
background: transparent;
border: none;
}
</style>
<!-- Load Leaflet CSS and JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
</head>
<body class="bg-gray-50 p-4 min-h-screen">

<div class="max-w-4xl mx-auto">
<h1 class="text-3xl font-extrabold text-center text-gray-800 mb-6 border-b pb-2">ğŸ§­ è·¯ç·šå¤©æ°£èˆ‡äººæµè­¦å ±ç³»çµ± (å¯æ‹–å‹•ä¿®æ­£ç‰ˆ)</h1>

<div class="bg-white p-6 rounded-xl shadow-lg mb-6">
<div class="space-y-4 md:flex md:space-x-4 md:space-y-0">
<div class="flex-1">
<label for="startLocation" class="block text-sm font-medium text-gray-700 mb-1">èµ·é» (A)</label>
<input id="startLocation" type="text" placeholder="è¼¸å…¥èµ·é»ï¼Œä¾‹å¦‚ï¼šå°–æ²™å’€ç«™" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
</div>
<div class="flex-1">
<label for="endLocation" class="block text-sm font-medium text-gray-700 mb-1">çµ‚é» (B)</label>
<input id="endLocation" type="text" placeholder="è¼¸å…¥çµ‚é»ï¼Œä¾‹å¦‚ï¼šæµ·æ¸¯åŸ" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
</div>
</div>
<button onclick="geocodeAndFindRoute()" id="routeButton" class="mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow-md transition duration-200 w-full">è¦åŠƒè·¯ç·šä¸¦æª¢æŸ¥è­¦å ±</button>
</div>

<!-- è­¦å ±å€åŸŸ -->
<div id="alertContainer" class="hidden mb-6">
<div id="alertBox" class="p-4 rounded-xl text-center font-semibold shadow-md transition duration-500 mb-2">
<!-- Alert message inserted here -->
</div>
<!-- iOS èªéŸ³æ’­æ”¾æŒ‰éˆ• -->
<button id="speakBtn" onclick="playLastSpeech()" class="w-full bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 rounded-lg flex items-center justify-center gap-2 transition">
<span>ğŸ”Š</span> æ’­æ”¾/é‡æ’­èªéŸ³æç¤º (iOS å°ˆç”¨)
</button>
</div>

<div id="mapContainer" class="relative">
<div id="map"></div>
<div id="loading" class="loading-overlay hidden">
<svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
<circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
<path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
</svg>
æ­£åœ¨è¦åŠƒ Valhalla è¡Œäººè·¯ç·š...
</div>
</div>

<div id="debugOutput" class="mt-6 p-4 bg-gray-100 rounded-lg text-sm text-gray-600 shadow-inner">
<!-- Debug/info output -->
<p><strong>ğŸ’¡ æç¤ºï¼š</strong>å¦‚æœèµ·é»æˆ–çµ‚é»ä½ç½®ä¸æº–ç¢ºï¼Œè«‹ç›´æ¥<strong>æ‹–å‹•åœ°åœ–ä¸Šçš„è—è‰²æ¨™è¨˜</strong>ä¾†ä¿®æ­£ï¼Œè·¯ç·šå°‡æœƒè‡ªå‹•é‡æ–°è¨ˆç®—ã€‚</p>
<div id="routeInfoContent" class="mt-2"></div>
</div>
</div>

<script>
// ============== é…ç½®èˆ‡å…¨å±€è®Šé‡ ==============
let map;
let routeLayer;
let startMarker; // å…¨å±€è®Šé‡ï¼šèµ·é»æ¨™è¨˜
let endMarker; // å…¨å±€è®Šé‡ï¼šçµ‚é»æ¨™è¨˜

const RAIN_API_URL = "https://crowdtest8r.ctakwah.workers.dev";
const VALHALLA_API_URL = "https://valhalla1.openstreetmap.de/route";
const NOMINATIM_API_URL = "https://nominatim.openstreetmap.org/search?format=json&q=";

const SAMPLE_INTERVAL_METERS = 1000;
const POI_CHECK_DISTANCE_METERS = 500;
const RAIN_THRESHOLD = 0.01;
let poiMarkers = L.layerGroup();
let lastSpeechText = "";

const CUSTOM_POIS = [
{ name: "æ—ºè§’ç«™", lat: 22.318357, lon: 114.169542, status: 3 },
{ name: "å°–æ²™å’€é˜æ¨“", lat: 22.293424, lon: 114.171170, status: 3 },
{ name: "ä¸­ç’°ç¢¼é ­", lat: 22.285810, lon: 114.156540, status: 2 },
{ name: "é¦™æ¸¯ç§‘å­¸é¤¨", lat: 22.3000, lon: 114.1754, status: 1 },
{ name: "é¦™æ¸¯æµ·æ´‹å…¬åœ’", lat: 22.2476, lon: 114.1755, status: 2 },
{ name: "æ²™ç”°é¦¬å ´", lat: 22.4048, lon: 114.2155, status: 3 },
{ name: "é¦™æ¸¯åœ‹éš›æ©Ÿå ´", lat: 22.3089, lon: 113.9147, status: 3 },
];

const POI_STATUS_MAP = {
3: { label: 'ğŸ”´ éå¸¸ç¹å¿™', color: 'red', icon: 'ğŸš¨' },
2: { label: 'ğŸŸ¡ äººæµåå¤š', color: 'orange', icon: 'âš ï¸' },
1: { label: 'ğŸŸ¢ äººæµæ­£å¸¸', color: 'green', icon: 'ğŸš¶' }
};

window.onload = function() {
initMap(22.302711, 114.177216);
};

document.getElementById("startLocation").addEventListener("keydown", function (e) {
if (e.key === "Enter") document.getElementById("endLocation").focus();
});
document.getElementById("endLocation").addEventListener("keydown", function (e) {
if (e.key === "Enter") geocodeAndFindRoute();
});

// ============== åœ°åœ–æ“ä½œå‡½æ•¸ ==============

function initMap(lat, lon) {
if (map) map.remove();
map = L.map("map").setView([lat, lon], 13);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
maxZoom: 19,
attribution: 'Â© OpenStreetMap contributors'
}).addTo(map);
poiMarkers.addTo(map);
}

function showLoading(show) {
document.getElementById('loading').classList.toggle('hidden', !show);
document.getElementById('routeButton').disabled = show;
}

function setAlert(message, type = 'safe') {
const alertContainer = document.getElementById('alertContainer');
const alertBox = document.getElementById('alertBox');

alertContainer.classList.remove('hidden');
alertBox.classList.remove('rain-alert', 'safe-alert', 'busy-alert', 'bg-red-100', 'bg-green-100', 'bg-yellow-100', 'text-red-800', 'text-green-800', 'text-yellow-800', 'border-red-400', 'border-green-400', 'border-yellow-400');
alertBox.style.borderColor = 'initial';

if (type === 'rain') {
alertBox.classList.add('rain-alert', 'bg-red-100', 'text-red-800', 'border-red-400');
} else if (type === 'busy') {
alertBox.classList.add('busy-alert');
} else if (type === 'safe') {
alertBox.classList.add('safe-alert', 'bg-green-100', 'text-green-800', 'border-green-400');
} else {
alertBox.classList.add('bg-gray-100', 'text-gray-800');
}
alertBox.innerHTML = message;
}

function playLastSpeech() {
if (lastSpeechText) {
speechSynthesis.cancel();
const utterance = new SpeechSynthesisUtterance(lastSpeechText);
utterance.lang = "zh-HK";
speechSynthesis.speak(utterance);
}
}

// ============== æ ¸å¿ƒæµç¨‹ï¼šåœ°ç†ç·¨ç¢¼ + æ¨™è¨˜è¨­ç½® ==============

// 1. ç”¨æˆ¶é»æ“ŠæŒ‰éˆ•ï¼šå…ˆæŸ¥è©¢åº§æ¨™ï¼Œå†è¨­ç½®æ¨™è¨˜
async function geocodeAndFindRoute() {
showLoading(true);
setAlert("æ­£åœ¨æŸ¥è©¢ä½ç½®...", 'info');
poiMarkers.clearLayers();

const startLoc = document.getElementById('startLocation').value.trim();
const endLoc = document.getElementById('endLocation').value.trim();

if (!startLoc || !endLoc) {
setAlert("â— è«‹è¼¸å…¥èµ·é»å’Œçµ‚é»ã€‚", 'info');
showLoading(false);
return;
}

try {
const startCoords = await getCoordinates(startLoc);
const endCoords = await getCoordinates(endLoc);

if (!startCoords || !endCoords) {
setAlert("âŒ ç„¡æ³•æ‰¾åˆ°èµ·é»æˆ–çµ‚é»çš„ç²¾ç¢ºåº§æ¨™ï¼Œè«‹å˜—è©¦æ›´å…·é«”çš„åç¨±ã€‚", 'error');
showLoading(false);
return;
}

// è¨­ç½®åœ°åœ–è¦–é‡
map.setView([startCoords.lat, startCoords.lon], 15);

// è¨­ç½®æˆ–æ›´æ–°æ¨™è¨˜ (åŠ å…¥ draggable: true)
setupMarkers(startCoords, endCoords);

// é–‹å§‹è¨ˆç®—è·¯ç·š
await calculateRouteFromMarkers();

} catch (error) {
console.error("éŒ¯èª¤:", error);
setAlert(`âŒ è™•ç†å¤±æ•—ï¼š${error.message}`, 'error');
showLoading(false);
}
}

// è¨­ç½®å¯æ‹–å‹•æ¨™è¨˜
function setupMarkers(startCoords, endCoords) {
// å¦‚æœæ¨™è¨˜å·²å­˜åœ¨ï¼Œç§»é™¤èˆŠçš„
if (startMarker) map.removeLayer(startMarker);
if (endMarker) map.removeLayer(endMarker);

// å‰µå»ºæ–°çš„å¯æ‹–å‹•æ¨™è¨˜
startMarker = L.marker([startCoords.lat, startCoords.lon], { draggable: true }).addTo(map).bindPopup("èµ·é» (å¯æ‹–å‹•ä¿®æ­£)").openPopup();
endMarker = L.marker([endCoords.lat, endCoords.lon], { draggable: true }).addTo(map).bindPopup("çµ‚é» (å¯æ‹–å‹•ä¿®æ­£)");

// ç›£è½æ‹–å‹•çµæŸäº‹ä»¶ -> é‡æ–°è¨ˆç®—è·¯ç·š
startMarker.on('dragend', function() {
calculateRouteFromMarkers();
});

endMarker.on('dragend', function() {
calculateRouteFromMarkers();
});
}

// 2. æ ¹æ“šç•¶å‰æ¨™è¨˜ä½ç½®è¨ˆç®—è·¯ç·š (Valhalla + å¤©æ°£)
async function calculateRouteFromMarkers() {
if (!startMarker || !endMarker) return;

showLoading(true);
setAlert("æ­£åœ¨æ ¹æ“šæ¨™è¨˜ä½ç½®é‡æ–°è¦åŠƒè·¯ç·š...", 'info');

try {
const startLatLng = startMarker.getLatLng();
const endLatLng = endMarker.getLatLng();

const startCoords = { lat: startLatLng.lat, lon: startLatLng.lng };
const endCoords = { lat: endLatLng.lat, lon: endLatLng.lng };

// [Valhalla] ç²å–è·¯ç·š
const routeData = await getValhallaRoute(startCoords, endCoords);

// ç¹ªè£½è·¯ç·š
const sampledPoints = drawRouteAndSamplePoints(routeData);

// æª¢æŸ¥å¤©æ°£èˆ‡äººæµ
const rainStatus = await checkRainForSampledPoints(sampledPoints);
const busyPOIs = checkCustomPOIsNearRoute(sampledPoints);

updateCombinedAlert(rainStatus, busyPOIs);

} catch (error) {
console.error("è·¯ç·šè¨ˆç®—éŒ¯èª¤:", error);
setAlert(`âŒ è·¯ç·šè¨ˆç®—å¤±æ•—ï¼š${error.message}`, 'error');
} finally {
showLoading(false);
}
}

// ============== API å‡½æ•¸ ==============

async function getCoordinates(query) {
// åŠ ä¸Š "Hong Kong" å¢åŠ æº–ç¢ºåº¦
const url = NOMINATIM_API_URL + encodeURIComponent(query + " Hong Kong");
const response = await fetch(url);
const data = await response.json();

if (data && data.length > 0) {
return {
lat: parseFloat(data[0].lat),
lon: parseFloat(data[0].lon)
};
}
return null;
}

async function getValhallaRoute(start, end) {
const requestBody = {
locations: [
{ lat: start.lat, lon: start.lon },
{ lat: end.lat, lon: end.lon }
],
costing: "pedestrian", // å¼·åˆ¶è¡Œäºº
directions_options: {
units: "km"
}
};

const url = `${VALHALLA_API_URL}?json=${encodeURIComponent(JSON.stringify(requestBody))}`;

const response = await fetch(url);
if (!response.ok) {
throw new Error(`å°èˆªæœå‹™éŒ¯èª¤ (Valhalla)`);
}
const data = await response.json();

if (!data.trip || !data.trip.legs || data.trip.legs.length === 0) {
throw new Error("æ‰¾ä¸åˆ°æœ‰æ•ˆçš„æ­¥è¡Œè·¯ç·šã€‚");
}

const leg = data.trip.legs[0];
const coordinates = decodePolyline(leg.shape);

return {
coordinates: coordinates,
distance: data.trip.summary.length * 1000,
duration: data.trip.summary.time
};
}

function decodePolyline(str, precision) {
var index = 0, lat = 0, lng = 0, coordinates = [], shift = 0, result = 0, byte = null, latitude_change, longitude_change, factor = Math.pow(10, precision || 6);
while (index < str.length) {
byte = null; shift = 0; result = 0;
do { byte = str.charCodeAt(index++) - 63; result |= (byte & 0x1f) << shift; shift += 5; } while (byte >= 0x20);
latitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));
shift = result = 0;
do { byte = str.charCodeAt(index++) - 63; result |= (byte & 0x1f) << shift; shift += 5; } while (byte >= 0x20);
longitude_change = ((result & 1) ? ~(result >> 1) : (result >> 1));
lat += latitude_change; lng += longitude_change;
coordinates.push([lat / factor, lng / factor]);
}
return coordinates;
}

function drawRouteAndSamplePoints(routeData) {
if (routeLayer) map.removeLayer(routeLayer);

const latLngs = routeData.coordinates;

routeLayer = L.polyline(latLngs, {
color: '#16a34a',
weight: 6,
opacity: 0.8,
dashArray: '5, 10'
}).addTo(map);

map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });

const sampledPoints = [];
let lastSampledCoord = latLngs[0];
sampledPoints.push({ lat: lastSampledCoord[0], lon: lastSampledCoord[1] });

let accumulatedDistance = 0;

for (let i = 1; i < latLngs.length; i++) {
const currentCoord = latLngs[i];
const segmentDistance = map.distance(lastSampledCoord, currentCoord);
accumulatedDistance += segmentDistance;

if (accumulatedDistance >= SAMPLE_INTERVAL_METERS) {
sampledPoints.push({ lat: currentCoord[0], lon: currentCoord[1] });
lastSampledCoord = currentCoord;
accumulatedDistance = 0;
}
}

document.getElementById('routeInfoContent').innerHTML = `
ç¸½è·é›¢ï¼šç´„ ${(routeData.distance / 1000).toFixed(2)} å…¬é‡Œ<br>
é è¨ˆæ­¥è¡Œæ™‚é–“ï¼šç´„ ${(routeData.duration / 60).toFixed(0)} åˆ†é˜<br>
å¤©æ°£æª¢æŸ¥é»æ•¸é‡ï¼š${sampledPoints.length} å€‹ (æ¯ 1 å…¬é‡Œå–æ¨£)`;

return sampledPoints;
}

// ============== å¤©æ°£æª¢æŸ¥å‡½æ•¸ ==============

async function checkRainForSampledPoints(points) {
let rainPointsCount = 0;
const checkPromises = points.map(point => checkSinglePointRain(point.lat, point.lon));
const results = await Promise.all(checkPromises);

const rainResults = results.filter(r => r.rainExpected);
rainPointsCount = rainResults.length;

map.eachLayer(layer => {
if (layer instanceof L.CircleMarker && layer.options.color === 'red') {
map.removeLayer(layer);
}
});

if (rainPointsCount > 0) {
const maxRainPoint = rainResults.sort((a, b) => b.immediateRain - a.immediateRain)[0];
rainResults.forEach(r => {
L.circleMarker([r.location.lat, r.location.lon], {
radius: 8, color: 'red', fillColor: '#f03', fillOpacity: 0.7,
}).addTo(map).bindPopup(`<strong>ğŸŒ§ï¸ é™é›¨æç¤º</strong><br>é è¨ˆé›¨é‡: ${r.immediateRain} mm/hr`);
});

return { hasRain: true, count: rainPointsCount, maxRain: maxRainPoint.immediateRain };
} else {
return { hasRain: false };
}
}

async function checkSinglePointRain(lat, lon) {
const url = `${RAIN_API_URL}/?lat=${lat}&lon=${lon}`;
const response = await fetch(url);
if (!response.ok) throw new Error("å¤©æ°£ Worker è«‹æ±‚å¤±æ•—ã€‚");
const data = await response.json();
data.location = { lat, lon };
return data;
}

// ============== äººæµ POI æª¢æŸ¥å‡½æ•¸ ==============

function checkCustomPOIsNearRoute(routePoints) {
const nearbyPOIs = new Set();
const busyPOIs = [];

poiMarkers.clearLayers();

for (const poi of CUSTOM_POIS) {
let isNearby = false;
for (const routePoint of routePoints) {
const distance = map.distance([poi.lat, poi.lon], [routePoint.lat, routePoint.lon]);
if (distance <= POI_CHECK_DISTANCE_METERS) {
isNearby = true;
break;
}
}

if (isNearby) {
if (poi.status >= 2) busyPOIs.push(poi);
const statusInfo = POI_STATUS_MAP[poi.status];
const customIcon = L.divIcon({
className: 'custom-poi-marker',
html: `<div class="bg-${statusInfo.color}-600 text-white text-lg rounded-full w-8 h-8 flex items-center justify-center shadow-lg border-2 border-white font-bold" style="background-color: ${statusInfo.color === 'red' ? '#dc2626' : statusInfo.color === 'orange' ? '#f97316' : '#10b981'};">${statusInfo.icon}</div>`,
iconSize: [32, 32],
iconAnchor: [16, 32],
popupAnchor: [0, -32]
});
L.marker([poi.lat, poi.lon], { icon: customIcon }).addTo(poiMarkers).bindPopup(`<strong>${poi.name}</strong><br>äººæµç‹€æ…‹: ${statusInfo.label}`);
}
}
return busyPOIs;
}

// ============== ç¶œåˆè­¦å ±å‡½æ•¸ ==============

function updateCombinedAlert(rainStatus, busyPOIs) {
let combinedMessage = ``;
let alertType = 'safe';
let rainText = "";
let poiText = "";
let speechText = "";

if (rainStatus.hasRain) {
rainText = `ğŸ”´ **å¤©æ°£è­¦å ±**ï¼šè·¯ç·šä¸Šæœ‰ ${rainStatus.count} è™•é è¨ˆæœ‰é›¨ï¼<br>(æœ€é«˜é›¨é‡: ${rainStatus.maxRain} mm/hr)`;
alertType = 'rain';
speechText += "æ³¨æ„ï¼Œè·¯ç·šä¸Šæœ‰é™é›¨é å ±ã€‚";
} else {
rainText = `ğŸŸ¢ **å¤©æ°£å®‰å…¨**ï¼šé è¨ˆæ²¿é€”æ²’æœ‰é™é›¨ã€‚`;
}

if (busyPOIs.length > 0) {
const names = busyPOIs.map(p => p.name).join('ã€');
poiText = `âš ï¸ **äººæµè­¦å ±**ï¼šè·¯ç·šé™„è¿‘æœ‰ ${busyPOIs.length} å€‹ç¹å¿™/åå¤šåœ°é»ï¼š${names}ã€‚`;
if (alertType !== 'rain') alertType = 'busy';
speechText += `è«‹ç•™æ„è·¯ç·šé™„è¿‘ ${names} çš„äººæµæƒ…æ³ã€‚`;
} else {
poiText = `âœ… **äººæµå®‰å…¨**ï¼šè·¯ç·šé™„è¿‘æ²’æœ‰ç‰¹åˆ¥ç¹å¿™çš„åœ°é»ã€‚`;
}

combinedMessage = `${rainText}<br><br>${poiText}`;
setAlert(combinedMessage, alertType);

lastSpeechText = speechText || "è·¯ç·šå®‰å…¨ï¼Œæ²’æœ‰å¤©æ°£æˆ–äººæµè­¦å ±ã€‚";

// å˜—è©¦è‡ªå‹•æ’­æ”¾
const finalSpeech = new SpeechSynthesisUtterance(lastSpeechText);
finalSpeech.lang = "zh-HK";
speechSynthesis.speak(finalSpeech);
}
</script>
</body>
</html>